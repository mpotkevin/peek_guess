<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ´ç‰©çŒœçŒœçœ‹ - è¦–çŸ¥è¦ºæˆ³æ´éŠæˆ²</title>
    <style>
        :root {
            /* è³ªæ„Ÿé…è‰² */
            --primary-action: #d35400;  /* æš–æ©˜ - å•Ÿç”¨ç‹€æ…‹ */
            --secondary-action: #34495e; /* æ·±è— */
            --bg-warm: #faf3e0;         /* æš–ç±³è‰²èƒŒæ™¯ */
            --panel-white: #ffffff;
            --border-color: #ecf0f1;
            --text-main: #2c3e50;
            --text-light: #7f8c8d;
            --mask-color: #e67e22; 
        }

        * { box-sizing: border-box; touch-action: manipulation; font-family: "Microsoft JhengHei", "PingFang TC", sans-serif; }

        body {
            margin: 0; padding: 0; background-color: var(--bg-warm);
            color: var(--text-main); display: flex; flex-direction: column; align-items: center; 
            min-height: 100vh; overflow-x: hidden;
        }

        header {
            width: 100%; background: var(--panel-white); color: var(--primary-action);
            padding: 10px; text-align: center; box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            border-bottom: 2px solid var(--border-color);
            transition: all 0.3s ease;
            z-index: 100;
        }

        .controls-hidden header { transform: translateY(-100%); margin-bottom: -45px; opacity: 0; pointer-events: none; }

        h1 { margin: 0; font-size: 22px; letter-spacing: 2px; font-weight: 900; }

        /* éŠæˆ²å€åŸŸæ ¸å¿ƒè¨­å®šï¼šå›ºå®š 4:3 æ¯”ä¾‹ */
        .game-wrapper {
            width: 95%; 
            max-width: 800px; 
            margin: 15px auto; 
            position: relative;
            transition: all 0.3s ease-in-out;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .game-view {
            width: 100%; 
            aspect-ratio: 4 / 3; 
            position: relative;
            background: #000000; /* èƒŒæ™¯é»‘è‰²ï¼Œè®“é 4:3 åœ–ç‰‡å‡ºç¾é»‘é‚Š */
            border-radius: 20px; overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.12); 
            display: flex; justify-content: center; align-items: center;
            border: 6px solid var(--panel-white);
            max-height: 70vh; 
        }

        #image-layer {
            position: absolute; 
            user-select: none; 
            z-index: 1;
            transition: transform 0.1s ease-out, opacity 0.4s ease;
            display: none; 
            opacity: 0;
            pointer-events: none; 
            /* ç§»é™¤é è¨­å¯¬é«˜é™åˆ¶ï¼Œç”± JS è¨ˆç®— */
        }
        
        /* èª¿æ•´éšæ®µå…è¨±æ‹–æ›³ */
        .preview-active #image-layer { pointer-events: auto; cursor: move; }

        #mask-svg {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none; transition: opacity 0.4s ease;
        }

        #interaction-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 20; transition: opacity 0.4s ease;
        }

        .hole-trigger {
            position: absolute; display: flex; justify-content: center; align-items: center;
            color: #ffffff; font-weight: bold; font-size: 28px; cursor: pointer;
            transition: width 0.1s, height 0.1s, transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            border: 2px dashed rgba(255,255,255,0.6);
            box-sizing: border-box;
        }

        /* æ™ºæ…§è‰²å½©ï¼šæ·ºè‰²é®ç½©æˆ–è¨­å®šæ¨¡å¼ä¸‹é¡¯ç¤ºæ·±è‰²æ–‡å­— */
        .dark-text .hole-trigger,
        .preview-active .hole-trigger {
            color: #000000 !important; text-shadow: none !important;
            border-color: rgba(0, 0, 0, 0.4) !important;
        }

        .hole-trigger:hover { border-color: currentColor; background-color: rgba(255,255,255,0.1); transform: scale(1.05); }
        .hole-trigger.revealed { opacity: 0; pointer-events: none; transform: scale(1.2); }

        /* è¨­å®šæ¨¡å¼æ¨£å¼ï¼šéš±è—é®ç½© */
        .preview-active #mask-svg { opacity: 0 !important; }
        .preview-active .hole-trigger { 
            border-style: solid; border-color: var(--primary-action) !important; 
            color: var(--primary-action) !important;
            background-color: rgba(211, 84, 0, 0.1);
        }

        /* æ§åˆ¶é¢æ¿ä½ˆå±€ */
        .control-panel {
            width: 95%; max-width: 800px; padding: 20px;
            background: var(--panel-white); border-radius: 20px; margin-bottom: 15px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.05);
            transition: all 0.3s ease;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .controls-hidden .control-panel { height: 0; padding: 0; margin-bottom: 0; opacity: 0; pointer-events: none; }
        .controls-hidden footer { opacity: 0; }

        .action-grid { display: flex; flex-direction: column; gap: 10px; width: 100%; }
        .action-row { display: flex; gap: 10px; width: 100%; justify-content: center; }
        .action-row > .btn { flex: 1; }

        .game-toolbar {
            width: 100%; max-width: 800px; 
            background: transparent;
            margin-top: 5px;
        }

        /* æŒ‰éˆ•è¦ç¯„ - ä¸€è‡´æ€§å¤§å°èˆ‡ç±³ç™½é¢¨æ ¼ */
        .btn {
            border: 2px solid var(--border-color); border-radius: 12px; cursor: pointer;
            font-weight: bold; transition: all 0.2s ease;
            display: inline-flex; align-items: center; justify-content: center;
            gap: 6px; text-align: center; outline: none;
            min-height: 46px; font-size: 15px; padding: 0 8px;
            background-color: #ffffff; color: var(--text-light);
        }
        .btn:active { transform: scale(0.96); opacity: 0.9; }
        .btn:hover { background-color: #f8f9fa; color: var(--text-main); border-color: #d1d8e0; }

        .btn-active {
            background-color: var(--primary-action) !important;
            color: #ffffff !important;
            border-color: var(--primary-action) !important;
        }

        .btn-small { min-height: 38px; font-size: 14px; border-radius: 10px; } 

        .toggle-ui-btn {
            position: fixed; right: 15px; bottom: 15px; z-index: 10002;
            width: 50px; height: 50px; border-radius: 50%;
            background: var(--secondary-action); color: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            font-size: 20px; border: none; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
        }

        .control-group { padding-bottom: 15px; border-bottom: 1px solid var(--border-color); }
        .control-group:last-child { border-bottom: none; }
        .label-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; font-weight: 800; font-size: 16px; color: var(--text-main); }

        .image-list {
            display: flex; flex-direction: column; gap: 6px; margin: 10px 0;
            max-height: 120px; overflow-y: auto; padding: 8px; background: #fdfdfd; border-radius: 14px; border: 1px solid var(--border-color);
        }
        .image-item {
            display: flex; align-items: center; padding: 8px; background: white;
            border-radius: 10px; cursor: pointer; border: 2px solid transparent; transition: 0.2s;
        }
        .image-item.active { border-color: var(--primary-action); background: #fffcf0; }
        .item-num { width: 26px; height: 26px; background: var(--primary-action); color: white; border-radius: 50%; display: flex; justify-content: center; align-items: center; margin-right: 10px; font-size: 12px; font-weight: bold; }
        .thumb { width: 45px; height: 35px; object-fit: cover; border-radius: 4px; margin-right: 10px; }

        .pattern-options { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
        .pattern-btn { width: 36px; height: 36px; border-radius: 50%; border: 3px solid #fff; cursor: pointer; box-shadow: 0 2px 6px rgba(0,0,0,0.1); background-size: cover; background-position: center; }
        .pattern-btn.active { border-color: var(--primary-action); transform: scale(1.1); }
        .btn-add-mask { font-size: 18px; color: var(--text-light); background: #eee; border: 2px dashed #ccc; display: flex; align-items: center; justify-content: center; }

        select { padding: 8px; font-size: 15px; border-radius: 10px; border: 1px solid var(--border-color); background: #fff; }
        input[type="range"] { width: 100%; height: 10px; background: #eee; border-radius: 4px; cursor: pointer; }

        footer {
            margin: 10px 0 30px 0; text-align: center; color: var(--text-light); font-size: 14px; width: 100%; transition: opacity 0.3s;
        }
        footer a { color: var(--primary-action); text-decoration: none; font-weight: bold; }

        .hide-mask #mask-svg, .hide-mask #interaction-layer { opacity: 0 !important; pointer-events: none !important; }

        @media (max-width: 600px) {
            .btn { font-size: 13px; min-height: 42px; border-radius: 10px; gap: 4px; }
            .action-row { gap: 6px; }
            .game-wrapper { margin: 10px auto; }
        }
    </style>
</head>
<body class="preview-active"> <!-- åˆå§‹ç‚ºè¨­å®šæ¨¡å¼ -->

<header id="page-header">
    <h1>æ´ç‰©çŒœçŒœçœ‹</h1>
</header>

<button class="toggle-ui-btn" id="toggle-ui" title="å±•é–‹/æ”¶èµ·è¨­å®š" onclick="toggleUIVisibility()">ğŸ› ï¸</button>

<div class="game-wrapper">
    <!-- éŠæˆ²ç•«å¸ƒèˆ‡é®ç½© -->
    <div class="game-view" id="game-canvas">
        <img id="image-layer" src="" alt="åº•åœ–" draggable="false">
        
        <svg id="mask-svg">
            <defs>
                <radialGradient id="grad-warm" cx="50%" cy="50%" r="70%">
                    <stop offset="0%" style="stop-color:#f39c12; stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#d35400; stop-opacity:1" />
                </radialGradient>
                <pattern id="pattern-wood" width="100" height="100" patternUnits="userSpaceOnUse">
                    <rect width="100" height="100" fill="#a67c52" />
                    <path d="M0 20 Q 50 10 100 20 M0 50 Q 50 60 100 50 M0 80 Q 50 70 100 80" stroke="#8d6641" fill="none" stroke-width="2" />
                </pattern>
                <pattern id="pattern-flowers" width="60" height="60" patternUnits="userSpaceOnUse">
                    <rect width="60" height="60" fill="#faf3e0" />
                    <text x="10" y="30" font-size="20" opacity="0.4">âœ¿</text>
                    <text x="40" y="50" font-size="15" opacity="0.3">â€</text>
                </pattern>
                <pattern id="pattern-linen" width="10" height="10" patternUnits="userSpaceOnUse">
                    <rect width="10" height="10" fill="#f5f5f5" />
                    <path d="M 10 0 L 10 10 M 0 10 L 10 10" stroke="#e0e0e0" stroke-width="0.5" />
                </pattern>
                <pattern id="pattern-custom" width="100%" height="100%" patternUnits="objectBoundingBox">
                    <image id="custom-mask-img" width="100%" height="100%" preserveAspectRatio="xMidYMid slice" xlink:href="" />
                </pattern>
                <mask id="hole-mask">
                    <rect width="100%" height="100%" fill="white" />
                    <g id="mask-holes-group"></g>
                </mask>
            </defs>
            <rect id="mask-rect" width="100%" height="100%" fill="url(#grad-warm)" mask="url(#hole-mask)" />
        </svg>

        <div id="interaction-layer"></div>
    </div>

    <!-- æ ¸å¿ƒæ“ä½œæŒ‰éˆ•å·¥å…·åˆ— -->
    <div class="game-toolbar">
        <div class="action-grid">
            <div class="action-row">
                <button class="btn btn-outline" onclick="goToPrevImage()">â®ï¸ ä¸Šä¸€é¡Œ</button>
                <button class="btn btn-outline" onclick="toggleAnswerRevealed()">ğŸ“¢ å…¬ä½ˆç­”æ¡ˆ</button>
                <button class="btn btn-outline" onclick="goToNextImage()">â­ï¸ ä¸‹ä¸€é¡Œ</button>
            </div>
            <div class="action-row">
                <button class="btn btn-outline" onclick="resetHoles()">ğŸ”„ é‡æ–°åˆ†ä½ˆ</button>
                <button class="btn btn-outline" onclick="undoHole()">â†©ï¸ å›ä¸Šä¸€æ­¥</button>
                <button class="btn btn-outline" onclick="revealAll()">ğŸ‘ï¸ å…¨éƒ¨æˆ³é–‹</button>
            </div>
            <div class="action-row">
                <button class="btn btn-outline" id="btn-start" onclick="toggleGameStart()" style="width: 100%;">ğŸ® é–‹å§‹éŠæˆ²</button>
            </div>
        </div>
    </div>
</div>

<!-- è©³ç´°è¨­å®šé¢æ¿ -->
<div class="control-panel" id="main-controls">
    <div class="control-group">
        <div class="label-row">
            <span>1. åœ–ç‰‡æ¸…å–®èˆ‡é®ç½©æ¨£å¼</span>
            <div class="pattern-options">
                <div class="pattern-btn active" style="background: #e67e22;" onclick="changeMask('warm', this)"></div>
                <div class="pattern-btn" style="background: #a67c52;" onclick="changeMask('wood', this)"></div>
                <div class="pattern-btn" style="background: #faf3e0; border: 1px solid #ddd;" onclick="changeMask('flowers', this)"></div>
                <div class="pattern-btn" style="background: #f5f5f5; border: 1px solid #ddd;" onclick="changeMask('linen', this)"></div>
                <div class="pattern-btn btn-add-mask" id="btn-custom-mask" title="ä¸Šå‚³è‡ªå®šç¾©é®ç½©" onclick="document.getElementById('mask-upload-input').click()">ï¼‹</div>
            </div>
        </div>
        
        <div style="display: flex; gap: 10px;">
            <button class="btn btn-outline btn-small" style="flex:1; background:#eee; color:#34495e;" onclick="document.getElementById('file-input').click()">â• ä¸Šå‚³é¡Œç›®åœ–</button>
            <button class="btn btn-outline btn-small" style="flex:1;" onclick="clearAllData()">ğŸ—‘ï¸ æ¸…ç©ºæ‰€æœ‰</button>
            <input type="file" id="file-input" accept="image/*" multiple style="display:none">
            <input type="file" id="mask-upload-input" accept="image/*" style="display:none" onchange="uploadCustomMask(this)">
        </div>

        <div class="image-list" id="image-list-ui"></div>

        <div id="current-adjust" style="display:none; padding: 10px; background: #fdfdfd; border-radius: 12px; border: 1px solid #eee;">
            <label class="label-row">ğŸ” å¾®èª¿åœ–ç‰‡å¤§å°: <span id="scale-val">100%</span></label>
            <input type="range" id="scale-slider" min="10" max="300" value="100">
        </div>
    </div>

    <div class="control-group">
        <div class="label-row">2. æ´å£åƒæ•¸è¨­å®š</div>
        <div style="display: flex; flex-wrap: wrap; gap: 10px; align-items: center;">
            <div>æ•¸é‡: <select id="hole-count" onchange="resetHoles()"><option value="4">4</option><option value="6">6</option><option value="8" selected>8</option><option value="12">12</option><option value="16">16</option><option value="24">24</option></select></div>
            <div>å½¢ç‹€: <select id="hole-shape" onchange="resetHoles()"><option value="circle">åœ“å½¢</option><option value="square">æ–¹å½¢</option></select></div>
            <div>æ’åˆ—: <select id="hole-layout" onchange="resetHoles()"><option value="random">éš¨æ©Ÿåˆ†æ•£</option><option value="grid">æ•´é½Šç¶²æ ¼</option></select></div>
        </div>
        <div style="margin-top: 10px;">
            <label class="label-row">ğŸ•³ï¸ æ´å£å¤§å°: <span id="size-val">120px</span></label>
            <input type="range" id="size-slider" min="50" max="250" value="120" oninput="updateSizePreview(this.value)">
        </div>
    </div>
</div>

<footer>
    è¨­è¨ˆï¼š<a href="https://www.facebook.com/kevin.pptgame" target="_blank">è·èƒ½æ²»ç™‚å¸« - é„­å‡±æ–‡</a>
</footer>

<script>
    // --- IndexedDB ---
    const DB_NAME = 'GuessGameDB_V5';
    const STORE_NAME = 'imagesStore';
    const DB_VERSION = 1;
    let db;

    function initDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains(STORE_NAME)) db.createObjectStore(STORE_NAME);
            };
            request.onsuccess = (e) => { db = e.target.result; resolve(db); };
            request.onerror = (e) => reject(e.target.error);
        });
    }

    async function saveToDB(data) {
        if (!db) await initDB();
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        return new Promise((resolve, reject) => {
            const request = store.put(data, 'gameState');
            request.onsuccess = () => resolve();
            request.onerror = (e) => reject(e.target.error);
        });
    }

    async function loadFromDB() {
        if (!db) await initDB();
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        return new Promise((resolve, reject) => {
            const request = store.get('gameState');
            request.onsuccess = (e) => resolve(e.target.result);
            request.onerror = (e) => reject(e.target.error);
        });
    }

    // --- è®Šæ•¸ç®¡ç† ---
    let images = []; 
    let currentIndex = -1;
    let isPreview = true; // åˆå§‹ç‚ºè¨­å®šæ¨¡å¼
    let isAnswerRevealed = false;
    let isDraggingImg = false;
    let startX, startY;
    let holeData = []; 
    let uiVisible = true;

    const canvas = document.getElementById('game-canvas');
    const imgLayer = document.getElementById('image-layer');
    const interactionLayer = document.getElementById('interaction-layer');
    const maskHolesGroup = document.getElementById('mask-holes-group');
    const maskRect = document.getElementById('mask-rect');
    const listUI = document.getElementById('image-list-ui');
    const scaleSlider = document.getElementById('scale-slider');
    const sizeSlider = document.getElementById('size-slider');
    const btnStart = document.getElementById('btn-start');

    window.onload = async () => {
        try {
            const savedData = await loadFromDB();
            if (savedData && Array.isArray(savedData)) {
                images = savedData;
                if (images.length > 0) {
                    currentIndex = 0;
                    renderList();
                    loadCurrent();
                }
            }
        } catch (e) { console.error("DB Load Fail", e); }
        resetHoles();
        setupInteraction();
    };

    // --- æ ¸å¿ƒï¼šé–‹å§‹éŠæˆ²èˆ‡è¨­å®šæ¨¡å¼åˆ‡æ› ---
    function toggleGameStart() {
        isPreview = !isPreview;
        if (!isPreview) {
            document.body.classList.remove('preview-active');
            btnStart.classList.add('btn-active');
            btnStart.innerText = 'ğŸ› ï¸ è¿”å›è¨­å®š';
        } else {
            document.body.classList.add('preview-active');
            btnStart.classList.remove('btn-active');
            btnStart.innerText = 'ğŸ® é–‹å§‹éŠæˆ²';
            isAnswerRevealed = false;
            canvas.parentElement.classList.remove('hide-mask');
        }
    }

    // --- ä»‹é¢æ”¶æ‘º ---
    function toggleUIVisibility() {
        uiVisible = !uiVisible;
        if (uiVisible) {
            document.body.classList.remove('controls-hidden');
            document.getElementById('toggle-ui').innerText = 'ğŸ› ï¸';
        } else {
            document.body.classList.add('controls-hidden');
            document.getElementById('toggle-ui').innerText = 'ğŸ“‚';
        }
    }

    // --- å³æ™‚å°ºå¯¸é è¦½ ---
    function updateSizePreview(value) {
        document.getElementById('size-val').innerText = value + 'px';
        const newSize = parseInt(value);
        holeData.forEach(h => { h.size = newSize; });
        const triggers = document.querySelectorAll('.hole-trigger');
        triggers.forEach(t => { t.style.width = newSize + 'px'; t.style.height = newSize + 'px'; });
        refreshMask();
    }

    // --- æ›é¡Œé‚è¼¯èˆ‡è‡ªå‹•ç¸®æ”¾ ---
    function goToNextImage() { if (images.length === 0) return; prepareSwitch(); currentIndex = (currentIndex + 1) % images.length; completeSwitch(); }
    function goToPrevImage() { if (images.length === 0) return; prepareSwitch(); currentIndex = (currentIndex - 1 + images.length) % images.length; completeSwitch(); }

    function prepareSwitch() {
        imgLayer.style.opacity = '0';
        imgLayer.style.display = 'none';
        imgLayer.src = ''; 
        isAnswerRevealed = false;
        canvas.parentElement.classList.remove('hide-mask');
    }

    function completeSwitch() {
        resetHoles(); 
        renderList();
        loadCurrent();
    }

    // æ ¸å¿ƒå„ªåŒ–ï¼šè‡ªå‹•è¨ˆç®—ç¸®æ”¾ä½¿åœ–ç‰‡å®Œå…¨é¡¯ç¤ºåœ¨ 4:3 å€åŸŸå…§
    function loadCurrent() {
        if (currentIndex === -1 || !images[currentIndex]) { imgLayer.style.display = 'none'; return; }
        const img = images[currentIndex];
        
        imgLayer.style.display = 'none';
        imgLayer.style.opacity = '0';
        imgLayer.src = img.src;
        
        imgLayer.onload = () => {
            const containerRect = canvas.getBoundingClientRect();
            const cW = containerRect.width || 800;
            const cH = containerRect.height || 600;
            
            // å¦‚æœè©²åœ–ç‰‡é‚„æ²’æœ‰æ‰‹å‹•èª¿æ•´éï¼ŒåŸ·è¡Œè‡ªå‹•ç¸®æ”¾
            if (img.scale === 1 && img.posX === 0 && img.posY === 0) {
                const imgW = imgLayer.naturalWidth;
                const imgH = imgLayer.naturalHeight;
                
                const ratioW = cW / imgW;
                const ratioH = cH / imgH;
                
                // å–è¼ƒå°çš„æ¯”ä¾‹ä»¥ç¢ºä¿æ•´å¼µåœ–éƒ½åœ¨æ¡†å…§ (Object-fit: contain é‚è¼¯)
                const fitScale = Math.min(ratioW, ratioH);
                img.scale = fitScale;
                img.posX = 0;
                img.posY = 0;
            }
            
            imgLayer.style.display = 'block';
            setTimeout(() => { imgLayer.style.opacity = '1'; }, 100);
            updateTransform();
            scaleSlider.value = Math.round(img.scale * 100);
            document.getElementById('scale-val').innerText = scaleSlider.value + '%';
        };
        
        refreshMask();
    }

    function toggleAnswerRevealed() {
        if (isPreview) return; 
        isAnswerRevealed = !isAnswerRevealed;
        if (isAnswerRevealed) canvas.parentElement.classList.add('hide-mask');
        else canvas.parentElement.classList.remove('hide-mask');
    }

    function changeMask(type, btn) {
        let fill = '';
        const isLight = (type === 'flowers' || type === 'linen' || type === 'custom');
        if (type === 'warm') fill = 'url(#grad-warm)';
        else if (type === 'wood') fill = 'url(#pattern-wood)';
        else if (type === 'flowers') fill = 'url(#pattern-flowers)';
        else if (type === 'linen') fill = 'url(#pattern-linen)';
        else if (type === 'custom') fill = 'url(#pattern-custom)';

        maskRect.setAttribute('fill', fill);
        document.querySelectorAll('.pattern-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');

        if (isLight) interactionLayer.classList.add('dark-text'); 
        else interactionLayer.classList.remove('dark-text'); 
    }

    function uploadCustomMask(input) {
        const file = input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            const customImg = document.getElementById('custom-mask-img');
            customImg.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', e.target.result);
            const btn = document.getElementById('btn-custom-mask');
            btn.style.backgroundImage = `url(${e.target.result})`;
            btn.innerText = '';
            changeMask('custom', btn);
        };
        reader.readAsDataURL(file);
    }

    document.getElementById('file-input').addEventListener('change', function(e) {
        const files = Array.from(e.target.files);
        let loaded = 0;
        files.forEach(file => {
            const reader = new FileReader();
            reader.onload = async (ev) => {
                images.push({
                    id: 'i_' + Date.now() + Math.random(),
                    src: ev.target.result,
                    name: file.name,
                    scale: 1, posX: 0, posY: 0,
                    revealedIds: []
                });
                loaded++;
                if (loaded === files.length) {
                    if (currentIndex === -1) currentIndex = 0;
                    renderList(); loadCurrent(); await save();
                }
            };
            reader.readAsDataURL(file);
        });
    });

    function renderList() {
        listUI.innerHTML = '';
        if (images.length === 0) { document.getElementById('current-adjust').style.display = 'none'; return; }
        document.getElementById('current-adjust').style.display = 'block';
        images.forEach((img, idx) => {
            const item = document.createElement('div');
            item.className = `image-item ${idx === currentIndex ? 'active' : ''}`;
            item.innerHTML = `<div class="item-num">${idx + 1}</div><img src="${img.src}" class="thumb"><div style="flex:1; font-weight:600; font-size:14px;">${img.name.substring(0,15)}...</div><button class="btn btn-outline btn-small" style="padding:0 10px; min-height:30px;" onclick="deleteImg(event, ${idx})">âœ•</button>`;
            item.onclick = () => { currentIndex = idx; isAnswerRevealed = false; canvas.parentElement.classList.remove('hide-mask'); renderList(); loadCurrent(); };
            listUI.appendChild(item);
        });
    }

    async function deleteImg(e, idx) { e.stopPropagation(); images.splice(idx, 1); if (currentIndex >= images.length) currentIndex = images.length - 1; renderList(); loadCurrent(); await save(); }

    function updateTransform() {
        if (currentIndex === -1) return;
        imgLayer.style.transform = `translate(${images[currentIndex].posX}px, ${images[currentIndex].posY}px) scale(${images[currentIndex].scale})`;
    }

    scaleSlider.oninput = async (e) => {
        if (currentIndex === -1) return;
        images[currentIndex].scale = e.target.value / 100;
        document.getElementById('scale-val').innerText = e.target.value + '%';
        updateTransform();
        await save();
    };

    function resetHoles() {
        interactionLayer.innerHTML = '';
        maskHolesGroup.innerHTML = '';
        holeData = [];
        const count = parseInt(document.getElementById('hole-count').value);
        const size = parseInt(sizeSlider.value);
        const shape = document.getElementById('hole-shape').value;
        const layout = document.getElementById('hole-layout').value;
        const rect = canvas.getBoundingClientRect();
        const cw = rect.width || 800;
        const ch = rect.height || 600;

        if (layout === 'grid') {
            const cols = Math.ceil(Math.sqrt(count));
            const rows = Math.ceil(count / cols);
            const cellW = cw / cols;
            const cellH = ch / rows;
            for (let i = 0; i < count; i++) {
                const r = Math.floor(i / cols);
                const c = i % cols;
                addHole(i + 1, c * cellW + (cellW - size) / 2, r * cellH + (cellH - size) / 2, size, shape);
            }
        } else {
            for (let i = 0; i < count; i++) {
                let attempts = 0;
                while (attempts < 200) {
                    const x = Math.random() * (cw - size);
                    const y = Math.random() * (ch - size);
                    const overlap = holeData.some(h => Math.sqrt(Math.pow(x - h.x, 2) + Math.pow(y - h.y, 2)) < size);
                    if (!overlap) { addHole(i + 1, x, y, size, shape); break; }
                    attempts++;
                }
            }
        }
        if (currentIndex !== -1) { images[currentIndex].revealedIds = []; save(); }
    }

    function addHole(num, x, y, size, shape) {
        const id = `h-${num}`;
        holeData.push({id, x, y, size, shape});
        const trigger = document.createElement('div');
        trigger.className = 'hole-trigger';
        trigger.id = `trigger-${id}`;
        trigger.innerText = num;
        trigger.style.width = trigger.style.height = size + 'px';
        trigger.style.left = x + 'px';
        trigger.style.top = y + 'px';
        trigger.style.borderRadius = shape === 'circle' ? '50%' : '12px';
        trigger.onclick = () => poke(id);
        interactionLayer.appendChild(trigger);
    }

    async function poke(id) {
        if (isPreview || currentIndex === -1 || isAnswerRevealed) return;
        if (!images[currentIndex].revealedIds.includes(id)) {
            images[currentIndex].revealedIds.push(id);
            refreshMask(); await save();
        }
    }

    function refreshMask() {
        maskHolesGroup.innerHTML = '';
        const revealed = (currentIndex !== -1) ? images[currentIndex].revealedIds : [];
        holeData.forEach(h => {
            const trigger = document.getElementById(`trigger-${h.id}`);
            if (revealed.includes(h.id)) {
                let shapeEl = document.createElementNS("http://www.w3.org/2000/svg", h.shape === 'circle' ? "circle" : "rect");
                if (h.shape === 'circle') {
                    shapeEl.setAttribute("cx", h.x + h.size / 2); shapeEl.setAttribute("cy", h.y + h.size / 2); shapeEl.setAttribute("r", h.size / 2);
                } else {
                    shapeEl.setAttribute("x", h.x); shapeEl.setAttribute("y", h.y); shapeEl.setAttribute("width", h.size); shapeEl.setAttribute("height", h.size); shapeEl.setAttribute("rx", 12);
                }
                shapeEl.setAttribute("fill", "black"); maskHolesGroup.appendChild(shapeEl);
                if (trigger) trigger.classList.add('revealed');
            } else { if (trigger) trigger.classList.remove('revealed'); }
        });
    }

    async function undoHole() { if (currentIndex === -1) return; images[currentIndex].revealedIds.pop(); refreshMask(); await save(); }
    async function revealAll() { if (currentIndex === -1) return; images[currentIndex].revealedIds = holeData.map(h => h.id); refreshMask(); await save(); }

    function setupInteraction() {
        const start = (e) => { 
            if (currentIndex === -1 || !isPreview) return; 
            isDraggingImg = true; 
            const cx = e.touches ? e.touches[0].clientX : e.clientX; 
            const cy = e.touches ? e.touches[0].clientY : e.clientY; 
            startX = cx - images[currentIndex].posX; 
            startY = cy - images[currentIndex].posY; 
        };
        const move = (e) => { 
            if (!isDraggingImg) return; 
            const cx = e.touches ? e.touches[0].clientX : e.clientX; 
            const cy = e.touches ? e.touches[0].clientY : e.clientY; 
            images[currentIndex].posX = cx - startX; 
            images[currentIndex].posY = cy - startY; 
            updateTransform(); 
        };
        const end = async () => { if(isDraggingImg) { isDraggingImg = false; await save(); } };
        canvas.addEventListener('mousedown', start); window.addEventListener('mousemove', move); window.addEventListener('mouseup', end);
        canvas.addEventListener('touchstart', start, {passive: false}); window.addEventListener('touchmove', move, {passive: false}); window.addEventListener('touchend', end);
    }

    async function save() { try { await saveToDB(images); } catch (e) { console.error("Save Error", e); } }
    async function clearAllData() { if (confirm('ç¢ºå®šæ¸…ç©ºæ‰€æœ‰åœ–ç‰‡ï¼Ÿ')) { const transaction = db.transaction([STORE_NAME], 'readwrite'); transaction.objectStore(STORE_NAME).clear(); location.reload(); } }
</script>

</body>
</html>
