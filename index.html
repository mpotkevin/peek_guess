<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ´ç‰©çŒœçŒœçœ‹ - è¦–çŸ¥è¦ºæˆ³æ´éŠæˆ²</title>
    <style>
        :root {
            /* è³ªæ„Ÿé…è‰² */
            --primary-action: #d35400;  /* æš–æ©˜ - å•Ÿç”¨ç‹€æ…‹ */
            --secondary-action: #34495e; /* æ·±è— */
            --bg-warm: #faf3e0;         /* æš–ç±³è‰²èƒŒæ™¯ */
            --panel-white: #ffffff;
            --border-color: #ecf0f1;
            --text-main: #2c3e50;
            --text-light: #7f8c8d;
            --mask-color: #e67e22; 
            --sidebar-width: 200px;
            --sidebar-collapsed-width: 70px;
        }

        * { box-sizing: border-box; touch-action: manipulation; font-family: "Microsoft JhengHei", "PingFang TC", sans-serif; }

        body {
            margin: 0; padding: 0; background-color: var(--bg-warm);
            color: var(--text-main); display: flex; flex-direction: row; 
            min-height: 100vh; height: 100vh; overflow: hidden;
        }

        /* å·¦å´å°è¦½åˆ— */
        .sidebar {
            width: var(--sidebar-width);
            background-color: var(--panel-white);
            border-right: 2px solid var(--border-color);
            display: flex;
            flex-direction: column;
            padding: 15px;
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            z-index: 100;
            flex-shrink: 0;
            height: 100vh;
        }

        .sidebar.collapsed {
            width: var(--sidebar-collapsed-width);
            padding: 15px 10px;
        }

        .sidebar.collapsed .sidebar-header h1,
        .sidebar.collapsed .btn span {
            display: none;
        }

        .sidebar-header { margin-bottom: 25px; text-align: center; height: 30px; }
        .sidebar-header h1 { margin: 0; font-size: 20px; color: var(--primary-action); letter-spacing: 1px; white-space: nowrap; }

        /* å·¦å´æ”¶æ‹‰æŒ‰éˆ• */
        .collapse-btn {
            background: var(--secondary-action);
            color: white;
            border: none;
            width: 28px; height: 28px;
            border-radius: 50%;
            position: absolute;
            right: -14px; top: 15px;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 110;
        }

        .nav-group { display: flex; flex-direction: column; gap: 10px; margin-bottom: 20px; }

        /* æŒ‰éˆ•æ¨£å¼ */
        .btn {
            border: 2px solid var(--border-color); border-radius: 12px; cursor: pointer;
            font-weight: bold; transition: all 0.2s ease;
            display: inline-flex; align-items: center; justify-content: flex-start;
            gap: 12px; text-align: left; outline: none;
            min-height: 48px; font-size: 15px; 
            background-color: #ffffff; color: var(--text-light);
            width: 100%;
            overflow: hidden;
            padding: 0 15px;
        }
        
        .sidebar.collapsed .btn { justify-content: center; padding: 0; }
        .btn i { font-style: normal; font-size: 18px; flex-shrink: 0; }
        .btn:active { transform: scale(0.96); opacity: 0.9; }
        .btn:hover { background-color: #f8f9fa; color: var(--text-main); border-color: #d1d8e0; }

        .btn-active {
            background-color: var(--primary-action) !important;
            color: #ffffff !important;
            border-color: var(--primary-action) !important;
        }

        /* å³å´ä¸»å€åŸŸ */
        .main-content {
            flex-grow: 1;
            height: 100vh;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px 15px 40px 15px;
            transition: all 0.3s ease;
            position: relative;
        }

        .game-wrapper {
            width: 100%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        /* éŠæˆ²è¦–çª— 4:3 */
        .game-view {
            width: 100%; 
            aspect-ratio: 4 / 3; 
            position: relative;
            background: #000000;
            border-radius: 24px; overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.12); 
            display: flex; justify-content: center; align-items: center;
            border: 8px solid var(--panel-white);
            max-height: 75vh; 
            flex-shrink: 0;
        }

        /* ç•«é¢å·¦ä¸Šè­°é¡Œæ¨™ */
        #question-badge {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 50;
            background-color: rgba(255, 255, 255, 0.2);
            color: #ffffff;
            padding: 6px 14px;
            border-radius: 30px;
            font-weight: 900;
            font-size: 16px;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            pointer-events: none;
            display: none; /* æœ‰é¡Œç›®æ™‚æ‰é¡¯ç¤º */
        }

        /* æ™ºæ…§è‰²å½©ï¼šæ·ºè‰²æ¨¡å¼ä¸‹çš„é¡Œæ¨™ */
        .dark-text #question-badge {
            color: #000000;
            background-color: rgba(0, 0, 0, 0.1);
            border-color: rgba(0, 0, 0, 0.2);
        }

        #image-layer {
            position: absolute; user-select: none; z-index: 1;
            transition: transform 0.1s ease-out, opacity 0.4s ease;
            display: none; opacity: 0;
            pointer-events: none; 
        }
        
        .preview-active #image-layer { pointer-events: auto; cursor: move; }

        #mask-svg {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none; transition: opacity 0.4s ease;
        }

        #interaction-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 20; transition: opacity 0.4s ease;
        }

        .hole-trigger {
            position: absolute; display: flex; justify-content: center; align-items: center;
            color: #ffffff; font-weight: bold; font-size: 28px; cursor: pointer;
            transition: width 0.1s, height 0.1s, transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            border: 3px dashed rgba(255,255,255,0.6);
            box-sizing: border-box;
        }

        .dark-text .hole-trigger,
        .preview-active .hole-trigger {
            color: #000000 !important; text-shadow: none !important;
            border-color: rgba(0, 0, 0, 0.4) !important;
        }

        .hole-trigger:hover { border-color: currentColor; background-color: rgba(255,255,255,0.1); transform: scale(1.05); }
        .hole-trigger.revealed { opacity: 0; pointer-events: none; transform: scale(1.2); }

        .preview-active #mask-svg { opacity: 0 !important; }
        .preview-active .hole-trigger { 
            border-style: solid; border-color: var(--primary-action) !important; 
            color: var(--primary-action) !important;
            background-color: rgba(211, 84, 0, 0.1);
        }

        /* ä¸‹æ–¹è¨­å®šé¢æ¿ */
        .bottom-settings {
            width: 100%;
            background-color: var(--panel-white);
            border-radius: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.05);
            overflow: hidden;
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .settings-header {
            padding: 14px 20px;
            background-color: #fcfcfc;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            font-weight: 800;
            color: var(--text-main);
            font-size: 15px;
        }
        .settings-header:hover { background-color: #f8f9fa; }

        .settings-content {
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            transition: all 0.3s ease;
            max-height: 1000px;
            overflow: hidden;
            opacity: 1;
        }

        .bottom-settings.collapsed .settings-content {
            max-height: 0;
            padding: 0 20px;
            opacity: 0;
            pointer-events: none;
        }

        .persistent-footer {
            padding: 12px 20px;
            background-color: #ffffff;
            border-top: 1px solid var(--border-color);
            text-align: center;
            font-size: 13px;
            color: var(--text-light);
        }
        .persistent-footer a {
            color: var(--primary-action);
            text-decoration: none;
            font-weight: bold;
        }

        .control-group { display: flex; flex-direction: column; gap: 10px; }
        .label-row { font-weight: 800; font-size: 14px; color: var(--text-main); margin-bottom: 5px; }

        /* åœ–ç‰‡æ¸…å–®é¡Œæ¨™ */
        .image-list {
            display: flex; flex-direction: column; gap: 6px;
            max-height: 150px; overflow-y: auto; padding: 10px; background: #fdfdfd; border-radius: 12px; border: 1px solid var(--border-color);
        }
        .image-item {
            display: flex; align-items: center; padding: 8px; background: white;
            border-radius: 10px; cursor: pointer; border: 2px solid transparent; transition: 0.2s;
            font-size: 13px;
        }
        .image-item.active { border-color: var(--primary-action); background: #fffcf0; }
        
        .list-num {
            width: 22px; height: 22px; background: var(--border-color); color: var(--text-light);
            border-radius: 50%; display: flex; justify-content: center; align-items: center;
            font-size: 11px; font-weight: 900; margin-right: 8px; flex-shrink: 0;
        }
        .image-item.active .list-num { background: var(--primary-action); color: #fff; }

        .thumb { width: 40px; height: 30px; object-fit: cover; border-radius: 4px; margin-right: 10px; }

        .pattern-options { display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 5px; }
        .pattern-btn { width: 36px; height: 36px; border-radius: 50%; border: 3px solid #fff; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.1); background-size: cover; background-position: center; }
        .pattern-btn.active { border-color: var(--primary-action); transform: scale(1.1); }
        .btn-add-mask { font-size: 20px; color: var(--text-light); background: #eee; border: 2px dashed #ccc; display: flex; align-items: center; justify-content: center; }

        select { width: 100%; padding: 10px; font-size: 14px; border-radius: 10px; border: 1px solid var(--border-color); background: #fff; outline: none; }
        input[type="range"] { width: 100%; cursor: pointer; }

        .hide-mask #mask-svg, .hide-mask #interaction-layer { opacity: 0 !important; pointer-events: none !important; }

        @media (max-width: 768px) {
            .settings-content { grid-template-columns: 1fr; }
            .sidebar.collapsed { width: 60px; }
        }
    </style>
</head>
<body class="preview-active"> <!-- åˆå§‹ç‚ºè¨­å®šæ¨¡å¼ -->

<div class="sidebar" id="sidebar">
    <button class="collapse-btn" onclick="toggleSidebar()">â¬…ï¸</button>
    
    <div class="sidebar-header">
        <h1>æ´ç‰©çŒœçŒœçœ‹</h1>
    </div>

    <div class="nav-group">
        <!-- æ ¸å¿ƒæ“ä½œæŒ‰éˆ•ï¼šæ›´æ–°æ–‡å­—ã€Œåˆ°ä¸Šä¸€é¡Œã€èˆ‡ã€Œåˆ°ä¸‹ä¸€é¡Œã€ -->
        <button class="btn btn-outline" id="btn-start" onclick="toggleGameStart()">
            <i>ğŸ®</i> <span>é–‹å§‹éŠæˆ²</span>
        </button>
        <button class="btn btn-outline" onclick="toggleAnswerRevealed()">
            <i>ğŸ‘ï¸</i> <span>å…¬ä½ˆç­”æ¡ˆ</span>
        </button>
        <button class="btn btn-outline" onclick="goToPrevImage()">
            <i>â®ï¸</i> <span>åˆ°ä¸Šä¸€é¡Œ</span>
        </button>
        <button class="btn btn-outline" onclick="goToNextImage()">
            <i>â­ï¸</i> <span>åˆ°ä¸‹ä¸€é¡Œ</span>
        </button>
        <button class="btn btn-outline" onclick="undoHole()">
            <i>â†©ï¸</i> <span>å›ä¸Šä¸€æ­¥</span>
        </button>
        <button class="btn btn-outline" onclick="resetHoles()">
            <i>ğŸ”„</i> <span>é‡æ–°åˆ†ä½ˆ</span>
        </button>
    </div>
</div>

<div class="main-content" id="scroll-content">
    <div class="game-wrapper" id="game-wrapper">
        <!-- ç…§ç‰‡é®ç½©å€ 4:3 -->
        <div class="game-view" id="game-canvas">
            <!-- ç•«é¢å·¦ä¸Šè­°é¡Œæ¨™ -->
            <div id="question-badge"></div>

            <img id="image-layer" src="" alt="åº•åœ–" draggable="false">
            
            <svg id="mask-svg">
                <defs>
                    <radialGradient id="grad-warm" cx="50%" cy="50%" r="70%">
                        <stop offset="0%" style="stop-color:#f39c12; stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#d35400; stop-opacity:1" />
                    </radialGradient>
                    <pattern id="pattern-wood" width="100" height="100" patternUnits="userSpaceOnUse">
                        <rect width="100" height="100" fill="#a67c52" />
                        <path d="M0 20 Q 50 10 100 20 M0 50 Q 50 60 100 50 M0 80 Q 50 70 100 80" stroke="#8d6641" fill="none" stroke-width="2" />
                    </pattern>
                    <pattern id="pattern-flowers" width="60" height="60" patternUnits="userSpaceOnUse">
                        <rect width="60" height="60" fill="#faf3e0" />
                        <text x="10" y="30" font-size="20" opacity="0.4">âœ¿</text>
                        <text x="40" y="50" font-size="15" opacity="0.3">â€</text>
                    </pattern>
                    <pattern id="pattern-linen" width="10" height="10" patternUnits="userSpaceOnUse">
                        <rect width="10" height="10" fill="#f5f5f5" />
                        <path d="M 10 0 L 10 10 M 0 10 L 10 10" stroke="#e0e0e0" stroke-width="0.5" />
                    </pattern>
                    <pattern id="pattern-custom" width="100%" height="100%" patternUnits="objectBoundingBox">
                        <image id="custom-mask-img" width="100%" height="100%" preserveAspectRatio="xMidYMid slice" xlink:href="" />
                    </pattern>
                    <mask id="hole-mask">
                        <rect width="100%" height="100%" fill="white" />
                        <g id="mask-holes-group"></g>
                    </mask>
                </defs>
                <rect id="mask-rect" width="100%" height="100%" fill="url(#grad-warm)" mask="url(#hole-mask)" />
            </svg>

            <div id="interaction-layer"></div>
        </div>

        <!-- ä¸‹æ–¹èª¿æ•´é¢æ¿ -->
        <div class="bottom-settings" id="bottom-settings">
            <div class="settings-header" onclick="toggleBottomSettings()">
                <span>ğŸ› ï¸ åƒæ•¸è¨­å®šå€ (é»æ“Šå±•é–‹/æ”¶èµ·)</span>
                <span id="settings-arrow">â–¼</span>
            </div>
            
            <div class="settings-content" id="settings-content">
                <div class="control-group">
                    <span class="label-row">é®ç½©æ¨£å¼</span>
                    <div class="pattern-options">
                        <div class="pattern-btn active" style="background: #e67e22;" onclick="changeMask('warm', this)"></div>
                        <div class="pattern-btn" style="background: #a67c52;" onclick="changeMask('wood', this)"></div>
                        <div class="pattern-btn" style="background: #faf3e0; border: 1px solid #ddd;" onclick="changeMask('flowers', this)"></div>
                        <div class="pattern-btn" style="background: #f5f5f5; border: 1px solid #ddd;" onclick="changeMask('linen', this)"></div>
                        <div class="pattern-btn btn-add-mask" id="btn-custom-mask" title="è‡ªå®šç¾©é®ç½©" onclick="document.getElementById('mask-upload-input').click()">ï¼‹</div>
                    </div>
                    
                    <span class="label-row">é¡Œç›®æ¸…å–®</span>
                    <button class="btn btn-outline" style="min-height:36px; font-size:13px;" onclick="document.getElementById('file-input').click()">â• ä¸Šå‚³æ–°é¡Œç›®</button>
                    <input type="file" id="file-input" accept="image/*" multiple style="display:none">
                    <input type="file" id="mask-upload-input" accept="image/*" style="display:none" onchange="uploadCustomMask(this)">
                    <div class="image-list" id="image-list-ui"></div>
                </div>

                <div class="control-group">
                    <span class="label-row">æ´å£æ•¸é‡èˆ‡å½¢ç‹€</span>
                    <div style="display:flex; gap:10px;">
                        <select id="hole-count" onchange="resetHoles()">
                            <option value="4">4å€‹</option><option value="6">6å€‹</option><option value="8" selected>8å€‹</option>
                            <option value="12">12å€‹</option><option value="16">16å€‹</option><option value="24">24å€‹</option>
                        </select>
                        <select id="hole-shape" onchange="resetHoles()">
                            <option value="circle">åœ“å½¢</option>
                            <option value="square">æ–¹å½¢</option>
                        </select>
                    </div>
                    
                    <span class="label-row">æ’åˆ—æ–¹å¼</span>
                    <select id="hole-layout" onchange="resetHoles()">
                        <option value="random">éš¨æ©Ÿåˆ†æ•£</option>
                        <option value="grid">æ•´é½Šç¶²æ ¼</option>
                    </select>

                    <span class="label-row">æ´å£å¤§å° (<span id="size-val">120px</span>)</span>
                    <input type="range" id="size-slider" min="50" max="250" value="120" oninput="updateSizePreview(this.value)">
                    
                    <div id="current-adjust" style="display:none; margin-top:5px;">
                        <span class="label-row">åº•åœ–å¾®èª¿ç¸®æ”¾ (<span id="scale-val">100%</span>)</span>
                        <input type="range" id="scale-slider" min="10" max="300" value="100">
                    </div>
                </div>
            </div>

            <!-- æŒä¹…é¡¯ç¤ºçš„ç½²å -->
            <div class="persistent-footer">
                è¨­è¨ˆï¼š<a href="https://www.facebook.com/kevin.pptgame" target="_blank">è·èƒ½æ²»ç™‚å¸« - é„­å‡±æ–‡</a>
            </div>
        </div>
    </div>
</div>

<script>
    // --- IndexedDB ---
    const DB_NAME = 'GuessGameDB_V8';
    const STORE_NAME = 'imagesStore';
    const DB_VERSION = 1;
    let db;

    function initDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains(STORE_NAME)) db.createObjectStore(STORE_NAME);
            };
            request.onsuccess = (e) => { db = e.target.result; resolve(db); };
            request.onerror = (e) => reject(e.target.error);
        });
    }

    async function saveToDB(data) {
        if (!db) await initDB();
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        return new Promise((resolve, reject) => {
            const request = store.put(data, 'gameState');
            request.onsuccess = () => resolve();
            request.onerror = (e) => reject(e.target.error);
        });
    }

    async function loadFromDB() {
        if (!db) await initDB();
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        return new Promise((resolve, reject) => {
            const request = store.get('gameState');
            request.onsuccess = (e) => resolve(e.target.result);
            request.onerror = (e) => reject(e.target.error);
        });
    }

    // --- è®Šæ•¸ ---
    let images = []; 
    let currentIndex = -1;
    let isPreview = true; 
    let isAnswerRevealed = false;
    let isDraggingImg = false;
    let startX, startY;
    let holeData = []; 
    let sidebarCollapsed = false;
    let bottomSettingsCollapsed = false;

    const canvas = document.getElementById('game-canvas');
    const imgLayer = document.getElementById('image-layer');
    const interactionLayer = document.getElementById('interaction-layer');
    const maskHolesGroup = document.getElementById('mask-holes-group');
    const maskRect = document.getElementById('mask-rect');
    const listUI = document.getElementById('image-list-ui');
    const scaleSlider = document.getElementById('scale-slider');
    const sizeSlider = document.getElementById('size-slider');
    const btnStart = document.getElementById('btn-start');
    const qBadge = document.getElementById('question-badge');

    window.onload = async () => {
        try {
            const savedData = await loadFromDB();
            if (savedData && Array.isArray(savedData)) {
                images = savedData;
                if (images.length > 0) {
                    currentIndex = 0;
                    renderList();
                    loadCurrent();
                }
            }
        } catch (e) { console.error("DB Load Fail", e); }
        resetHoles();
        setupInteraction();
    };

    function toggleSidebar() {
        sidebarCollapsed = !sidebarCollapsed;
        const sb = document.getElementById('sidebar');
        const btn = document.querySelector('.collapse-btn');
        if (sidebarCollapsed) {
            sb.classList.add('collapsed');
            btn.innerText = 'â¡ï¸';
        } else {
            sb.classList.remove('collapsed');
            btn.innerText = 'â¬…ï¸';
        }
        setTimeout(loadCurrent, 300);
    }

    function toggleBottomSettings() {
        bottomSettingsCollapsed = !bottomSettingsCollapsed;
        const panel = document.getElementById('bottom-settings');
        const arrow = document.getElementById('settings-arrow');
        if (bottomSettingsCollapsed) {
            panel.classList.add('collapsed');
            arrow.innerText = 'â–²';
        } else {
            panel.classList.remove('collapsed');
            arrow.innerText = 'â–¼';
        }
    }

    function toggleGameStart() {
        isPreview = !isPreview;
        if (!isPreview) {
            document.body.classList.remove('preview-active');
            btnStart.classList.add('btn-active');
            btnStart.innerHTML = '<i>ğŸ› ï¸</i> <span>è¿”å›è¨­å®š</span>';
        } else {
            document.body.classList.add('preview-active');
            btnStart.classList.remove('btn-active');
            btnStart.innerHTML = '<i>ğŸ®</i> <span>é–‹å§‹éŠæˆ²</span>';
            isAnswerRevealed = false;
            canvas.parentElement.classList.remove('hide-mask');
        }
    }

    function updateSizePreview(value) {
        document.getElementById('size-val').innerText = value + 'px';
        const newSize = parseInt(value);
        holeData.forEach(h => { h.size = newSize; });
        const triggers = document.querySelectorAll('.hole-trigger');
        triggers.forEach(t => { 
            t.style.width = newSize + 'px'; 
            t.style.height = newSize + 'px'; 
        });
        refreshMask();
    }

    function toggleAnswerRevealed() {
        if (isPreview) return; 
        isAnswerRevealed = !isAnswerRevealed;
        if (isAnswerRevealed) canvas.parentElement.classList.add('hide-mask');
        else canvas.parentElement.classList.remove('hide-mask');
    }

    function goToNextImage() { if (images.length === 0) return; prepareSwitch(); currentIndex = (currentIndex + 1) % images.length; completeSwitch(); }
    function goToPrevImage() { if (images.length === 0) return; prepareSwitch(); currentIndex = (currentIndex - 1 + images.length) % images.length; completeSwitch(); }

    function prepareSwitch() {
        imgLayer.style.opacity = '0'; imgLayer.style.display = 'none'; imgLayer.src = ''; 
        isAnswerRevealed = false; canvas.parentElement.classList.remove('hide-mask');
    }

    function completeSwitch() { resetHoles(); renderList(); loadCurrent(); }

    function loadCurrent() {
        if (currentIndex === -1 || !images[currentIndex]) { 
            imgLayer.style.display = 'none'; 
            qBadge.style.display = 'none';
            return; 
        }
        const img = images[currentIndex];
        
        // æ›´æ–°é¡Œè™Ÿé¡Œæ¨™
        qBadge.innerText = `ç¬¬ ${currentIndex + 1} é¡Œ`;
        qBadge.style.display = 'block';

        imgLayer.style.display = 'none'; imgLayer.style.opacity = '0'; imgLayer.src = img.src;
        
        imgLayer.onload = () => {
            const containerRect = canvas.getBoundingClientRect();
            const cW = containerRect.width || 800;
            const cH = containerRect.height || 600;
            
            if (img.scale === 1 && img.posX === 0 && img.posY === 0) {
                const ratioW = cW / imgLayer.naturalWidth;
                const ratioH = cH / imgLayer.naturalHeight;
                img.scale = Math.min(ratioW, ratioH);
            }
            
            imgLayer.style.display = 'block';
            setTimeout(() => { imgLayer.style.opacity = '1'; }, 100);
            updateTransform();
            scaleSlider.value = Math.round(img.scale * 100);
            document.getElementById('scale-val').innerText = scaleSlider.value + '%';
        };
        refreshMask();
    }

    function changeMask(type, btn) {
        let fill = '';
        if (type === 'warm') fill = 'url(#grad-warm)';
        else if (type === 'wood') fill = 'url(#pattern-wood)';
        else if (type === 'flowers') fill = 'url(#pattern-flowers)';
        else if (type === 'linen') fill = 'url(#pattern-linen)';
        else if (type === 'custom') fill = 'url(#pattern-custom)';

        maskRect.setAttribute('fill', fill);
        document.querySelectorAll('.pattern-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');

        const isLight = (type === 'flowers' || type === 'linen' || type === 'custom');
        if (isLight) interactionLayer.classList.add('dark-text'); 
        else interactionLayer.classList.remove('dark-text'); 
    }

    function uploadCustomMask(input) {
        const file = input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            const customImg = document.getElementById('custom-mask-img');
            customImg.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', e.target.result);
            const btn = document.getElementById('btn-custom-mask');
            btn.style.backgroundImage = `url(${e.target.result})`;
            btn.innerText = '';
            changeMask('custom', btn);
        };
        reader.readAsDataURL(file);
    }

    document.getElementById('file-input').addEventListener('change', function(e) {
        const files = Array.from(e.target.files);
        let loaded = 0;
        files.forEach(file => {
            const reader = new FileReader();
            reader.onload = async (ev) => {
                images.push({
                    id: 'i_' + Date.now() + Math.random(),
                    src: ev.target.result, name: file.name,
                    scale: 1, posX: 0, posY: 0, revealedIds: []
                });
                loaded++;
                if (loaded === files.length) {
                    if (currentIndex === -1) currentIndex = 0;
                    renderList(); loadCurrent(); await save();
                }
            };
            reader.readAsDataURL(file);
        });
    });

    function renderList() {
        listUI.innerHTML = '';
        if (images.length === 0) { document.getElementById('current-adjust').style.display = 'none'; return; }
        document.getElementById('current-adjust').style.display = 'block';
        images.forEach((img, idx) => {
            const item = document.createElement('div');
            item.className = `image-item ${idx === currentIndex ? 'active' : ''}`;
            item.innerHTML = `
                <div class="list-num">${idx + 1}</div>
                <img src="${img.src}" class="thumb">
                <div style="flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${img.name.substring(0,10)}...</div>
                <button class="btn" style="min-height:24px; width:auto; padding:2px 6px; border-radius:6px; font-size:10px; border-color:#eee;" onclick="deleteImg(event, ${idx})">âœ•</button>
            `;
            item.onclick = () => { currentIndex = idx; isAnswerRevealed = false; canvas.parentElement.classList.remove('hide-mask'); renderList(); loadCurrent(); };
            listUI.appendChild(item);
        });
    }

    async function deleteImg(e, idx) { e.stopPropagation(); images.splice(idx, 1); if (currentIndex >= images.length) currentIndex = images.length - 1; renderList(); loadCurrent(); await save(); }

    function updateTransform() {
        if (currentIndex === -1) return;
        imgLayer.style.transform = `translate(${images[currentIndex].posX}px, ${images[currentIndex].posY}px) scale(${images[currentIndex].scale})`;
    }

    scaleSlider.oninput = async (e) => {
        if (currentIndex === -1) return;
        images[currentIndex].scale = e.target.value / 100;
        document.getElementById('scale-val').innerText = e.target.value + '%';
        updateTransform(); await save();
    };

    function resetHoles() {
        const countEl = document.getElementById('hole-count');
        const shapeEl = document.getElementById('hole-shape');
        const layoutEl = document.getElementById('hole-layout');
        if (!countEl || !shapeEl || !layoutEl) return;

        interactionLayer.innerHTML = ''; maskHolesGroup.innerHTML = ''; holeData = [];
        const count = parseInt(countEl.value);
        const size = parseInt(sizeSlider.value);
        const shape = shapeEl.value;
        const layout = layoutEl.value;
        const rect = canvas.getBoundingClientRect();
        const cw = rect.width || 800; const ch = rect.height || 600;

        if (layout === 'grid') {
            const cols = Math.ceil(Math.sqrt(count)); const rows = Math.ceil(count / cols);
            const cellW = cw / cols; const cellH = ch / rows;
            for (let i = 0; i < count; i++) {
                const r = Math.floor(i / cols); const c = i % cols;
                addHole(i + 1, c * cellW + (cellW - size) / 2, r * ch + (ch - size) / 2, size, shape);
            }
        } else {
            for (let i = 0; i < count; i++) {
                let attempts = 0;
                while (attempts < 200) {
                    const x = Math.random() * (cw - size); const y = Math.random() * (ch - size);
                    const overlap = holeData.some(h => Math.sqrt(Math.pow(x - h.x, 2) + Math.pow(y - h.y, 2)) < size);
                    if (!overlap) { addHole(i + 1, x, y, size, shape); break; }
                    attempts++;
                }
            }
        }
        if (currentIndex !== -1) { images[currentIndex].revealedIds = []; save(); }
    }

    function addHole(num, x, y, size, shape) {
        const id = `h-${num}`; holeData.push({id, x, y, size, shape});
        const trigger = document.createElement('div');
        trigger.className = 'hole-trigger'; trigger.id = `trigger-${id}`; trigger.innerText = num;
        trigger.style.width = trigger.style.height = size + 'px';
        trigger.style.left = x + 'px'; trigger.style.top = y + 'px';
        trigger.style.borderRadius = shape === 'circle' ? '50%' : '12px';
        trigger.onclick = () => poke(id);
        interactionLayer.appendChild(trigger);
    }

    async function poke(id) {
        if (isPreview || currentIndex === -1 || isAnswerRevealed) return;
        if (!images[currentIndex].revealedIds.includes(id)) {
            images[currentIndex].revealedIds.push(id);
            refreshMask(); await save();
        }
    }

    function refreshMask() {
        maskHolesGroup.innerHTML = '';
        const revealed = (currentIndex !== -1) ? images[currentIndex].revealedIds : [];
        holeData.forEach(h => {
            const trigger = document.getElementById(`trigger-${h.id}`);
            if (revealed.includes(h.id)) {
                let shapeEl = document.createElementNS("http://www.w3.org/2000/svg", h.shape === 'circle' ? "circle" : "rect");
                if (h.shape === 'circle') {
                    shapeEl.setAttribute("cx", h.x + h.size / 2); shapeEl.setAttribute("cy", h.y + h.size / 2); shapeEl.setAttribute("r", h.size / 2);
                } else {
                    shapeEl.setAttribute("x", h.x); shapeEl.setAttribute("y", h.y); shapeEl.setAttribute("width", h.size); shapeEl.setAttribute("height", h.size); shapeEl.setAttribute("rx", 12);
                }
                shapeEl.setAttribute("fill", "black"); maskHolesGroup.appendChild(shapeEl);
                if (trigger) trigger.classList.add('revealed');
            } else { if (trigger) trigger.classList.remove('revealed'); }
        });
    }

    async function undoHole() { if (currentIndex === -1) return; images[currentIndex].revealedIds.pop(); refreshMask(); await save(); }

    function setupInteraction() {
        const start = (e) => { if (currentIndex === -1 || !isPreview) return; isDraggingImg = true; const cx = e.touches ? e.touches[0].clientX : e.clientX; const cy = e.touches ? e.touches[0].clientY : e.clientY; startX = cx - images[currentIndex].posX; startY = cy - images[currentIndex].posY; };
        const move = (e) => { if (!isDraggingImg) return; const cx = e.touches ? e.touches[0].clientX : e.clientX; const cy = e.touches ? e.touches[0].clientY : e.clientY; images[currentIndex].posX = cx - startX; images[currentIndex].posY = cy - startY; updateTransform(); };
        const end = async () => { if(isDraggingImg) { isDraggingImg = false; await save(); } };
        canvas.addEventListener('mousedown', start); window.addEventListener('mousemove', move); window.addEventListener('mouseup', end);
        canvas.addEventListener('touchstart', start, {passive: false}); window.addEventListener('touchmove', move, {passive: false}); window.addEventListener('touchend', end);
    }

    async function save() { try { await saveToDB(images); } catch (e) { console.error("Save Error", e); } }
    async function clearAllData() { if (confirm('ç¢ºå®šæ¸…ç©ºæ‰€æœ‰åœ–ç‰‡ï¼Ÿ')) { const transaction = db.transaction([STORE_NAME], 'readwrite'); transaction.objectStore(STORE_NAME).clear(); location.reload(); } }
</script>

</body>
</html>
