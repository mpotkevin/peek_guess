<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ´ç‰©çŒœçŒœçœ‹ - è¦–çŸ¥è¦ºæˆ³æ´éŠæˆ²</title>
    <style>
        :root {
            /* è³ªæ„Ÿé…è‰² */
            --primary-action: #d35400;  /* æš–æ©˜ - ä¸»è¡Œå‹• / å•Ÿç”¨ç‹€æ…‹ */
            --secondary-action: #34495e; /* æ·±è— */
            --bg-warm: #faf3e0;         /* æš–ç±³è‰²èƒŒæ™¯ */
            --panel-white: #ffffff;
            --border-color: #ecf0f1;
            --text-main: #2c3e50;
            --text-light: #7f8c8d;
            --mask-color: #e67e22; 
        }

        * { box-sizing: border-box; touch-action: manipulation; font-family: "Microsoft JhengHei", "PingFang TC", sans-serif; }

        body {
            margin: 0; padding: 0; background-color: var(--bg-warm);
            color: var(--text-main); display: flex; flex-direction: column; align-items: center; min-height: 100vh;
        }

        header {
            width: 100%; background: var(--panel-white); color: var(--primary-action);
            padding: 15px; text-align: center; box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            border-bottom: 2px solid var(--border-color);
        }

        h1 { margin: 0; font-size: 24px; letter-spacing: 2px; font-weight: 900; }

        /* éŠæˆ²è¦–çª— */
        .game-wrapper {
            width: 95%; max-width: 850px; margin: 20px auto; position: relative;
            transition: all 0.3s ease-in-out;
        }

        .game-view {
            width: 100%; position: relative;
            background: #1a1a1a; border-radius: 24px; overflow: hidden;
            box-shadow: 0 15px 45px rgba(0,0,0,0.15); 
            aspect-ratio: 4 / 3;
            display: flex; justify-content: center; align-items: center;
            border: 8px solid var(--panel-white);
        }

        #image-layer {
            position: absolute; cursor: move; user-select: none; z-index: 1;
            transition: transform 0.1s ease-out, opacity 0.4s ease;
            display: none; opacity: 0;
        }

        #mask-svg {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none; transition: opacity 0.4s ease;
        }

        #interaction-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 20; transition: opacity 0.4s ease;
        }

        /* æ´å£æ¨£å¼ */
        .hole-trigger {
            position: absolute; display: flex; justify-content: center; align-items: center;
            color: #ffffff; font-weight: bold; font-size: 32px; cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            border: 3px dashed rgba(255,255,255,0.6);
            box-sizing: border-box;
        }

        /* æ·±è‰²æ–‡å­—é©æ‡‰ */
        .dark-text .hole-trigger {
            color: #000000 !important;
            text-shadow: none !important;
            border-color: rgba(0, 0, 0, 0.5) !important;
        }

        .hole-trigger:hover {
            border-color: currentColor; background-color: rgba(255,255,255,0.1); transform: scale(1.05);
        }

        .hole-trigger.revealed { opacity: 0; pointer-events: none; transform: scale(1.2); }

        /* èª¿æ•´æ¨¡å¼æ¨£å¼ */
        .preview-active #mask-svg { opacity: 0 !important; }
        .preview-active .hole-trigger { 
            border-style: solid; 
            border-color: var(--primary-action); 
            text-shadow: none;
            color: var(--primary-action);
            background-color: rgba(211, 84, 0, 0.1);
        }

        /* å…¨è¢å¹•æ¨¡å¼ */
        .game-wrapper.mock-fullscreen {
            position: fixed !important; top: 0 !important; left: 0 !important;
            width: 100vw !important; height: 100vh !important; max-width: none !important;
            margin: 0 !important; z-index: 9999; background-color: var(--bg-warm);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 10px;
        }

        .game-wrapper.mock-fullscreen .game-view {
            width: 90vw; height: auto; max-height: 70vh; border: 6px solid var(--panel-white);
        }

        .fullscreen-exit { 
            display: none; 
            margin-bottom: 15px; 
            z-index: 10000; 
        }
        .mock-fullscreen .fullscreen-exit { display: inline-flex !important; }

        /* å…¬ä½ˆç­”æ¡ˆéš±è—é®ç½© */
        .hide-mask #mask-svg, .hide-mask #interaction-layer { opacity: 0 !important; pointer-events: none !important; }

        /* æ§åˆ¶é¢æ¿ä½ˆå±€ */
        .control-panel {
            width: 95%; max-width: 850px; padding: 25px;
            background: var(--panel-white); border-radius: 24px; margin-bottom: 20px;
            box-shadow: 0 5px 25px rgba(0,0,0,0.05);
        }

        .action-grid { display: flex; flex-direction: column; gap: 12px; width: 100%; }
        .action-row { display: flex; gap: 12px; width: 100%; }
        .action-row > .btn { flex: 1; }

        /* å…¨è¢å¹•å·¥å…·åˆ— */
        .game-toolbar {
            display: none; margin-top: 15px; width: 100%; max-width: 650px;
            padding: 15px; background: rgba(255,255,255,0.95); border-radius: 24px;
            border: 1px solid var(--border-color); backdrop-filter: blur(10px);
        }
        .mock-fullscreen .game-toolbar { display: block; }

        /* æŒ‰éˆ•è¦ç¯„ - çµ±ä¸€å°ºå¯¸èˆ‡é¢¨æ ¼ */
        .btn {
            border: none; border-radius: 16px; cursor: pointer;
            font-weight: bold; transition: all 0.2s ease;
            display: inline-flex; align-items: center; justify-content: center;
            gap: 8px; text-align: center; outline: none;
            min-height: 56px; 
            font-size: 17px;
            padding: 0 10px;
        }
        .btn:active { transform: scale(0.96); opacity: 0.9; }

        /* çµ±ä¸€é¡è‰²æ¨£å¼ï¼šç±³ç™½åº• (btn-outline) */
        .btn-outline { 
            background-color: #ffffff; 
            border: 2px solid var(--border-color); 
            color: var(--text-light); 
        }
        .btn-outline:hover { 
            background-color: #f8f9fa; 
            border-color: #d1d8e0;
            color: var(--text-main);
        }

        /* å•Ÿç”¨ç‹€æ…‹æ¨£å¼ï¼šæ©˜è‰² (btn-active) */
        .btn-active {
            background-color: var(--primary-action) !important;
            color: #ffffff !important;
            border-color: var(--primary-action) !important;
            box-shadow: 0 4px 12px rgba(211, 84, 0, 0.2);
        }

        .btn-secondary { background-color: var(--secondary-action); color: white; }
        .btn-small { min-height: 44px; font-size: 15px; border-radius: 12px; } 

        .control-group { margin-bottom: 25px; padding-bottom: 20px; border-bottom: 1px solid var(--border-color); }
        .control-group:last-child { border-bottom: none; }

        .label-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; font-weight: 800; font-size: 18px; color: var(--text-main); }

        .image-list {
            display: flex; flex-direction: column; gap: 8px; margin: 15px 0;
            max-height: 180px; overflow-y: auto; padding: 10px; background: #fdfdfd; 
            border-radius: 16px; border: 1px solid var(--border-color);
        }

        .image-item {
            display: flex; align-items: center; padding: 10px; background: white;
            border-radius: 14px; cursor: grab; border: 2px solid transparent;
            user-select: none; transition: 0.2s; box-shadow: 0 2px 6px rgba(0,0,0,0.02);
        }
        .image-item.active { border-color: var(--primary-action); background: #fffcf0; }
        .item-num { width: 30px; height: 30px; background: var(--primary-action); color: white; border-radius: 50%; display: flex; justify-content: center; align-items: center; margin-right: 12px; font-size: 14px; font-weight: bold; }
        .thumb { width: 50px; height: 40px; object-fit: cover; border-radius: 6px; margin-right: 12px; border: 1px solid #eee; }

        /* æ¨£å¼è¨­å®š */
        .pattern-options { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
        .pattern-btn { width: 42px; height: 42px; border-radius: 50%; border: 3px solid #fff; cursor: pointer; box-shadow: 0 2px 6px rgba(0,0,0,0.1); background-size: cover; background-position: center; transition: transform 0.2s; }
        .pattern-btn.active { border-color: var(--primary-action); transform: scale(1.1); }
        
        .btn-add-mask {
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; color: var(--text-light); background: #eee; border: 2px dashed #ccc;
        }

        select { padding: 10px; font-size: 16px; border-radius: 12px; border: 1px solid var(--border-color); background: #fff; }
        input[type="range"] { width: 100%; height: 10px; background: #eee; border-radius: 5px; }

        footer {
            margin: 20px 0 40px 0;
            text-align: center;
            color: var(--text-light);
            font-size: 16px;
            width: 100%;
        }
        footer a { color: var(--primary-action); text-decoration: none; font-weight: bold; }

        @media (max-width: 600px) {
            .btn { font-size: 14px; min-height: 48px; border-radius: 12px; gap: 4px; }
            .game-wrapper.mock-fullscreen .game-view { max-height: 55vh; }
        }
    </style>
</head>
<body>

<header id="page-header">
    <h1>æ´ç‰©çŒœçŒœçœ‹</h1>
</header>

<div class="game-wrapper" id="fullscreen-target">
    <button class="btn btn-outline btn-small fullscreen-exit" id="exit-fs-btn" onclick="exitMockFullscreen()">âœ– é€€å‡ºå…¨è¢å¹•</button>

    <div class="game-view" id="game-canvas">
        <img id="image-layer" src="" alt="åº•åœ–" draggable="false">
        
        <svg id="mask-svg">
            <defs>
                <radialGradient id="grad-warm" cx="50%" cy="50%" r="70%">
                    <stop offset="0%" style="stop-color:#f39c12; stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#d35400; stop-opacity:1" />
                </radialGradient>

                <pattern id="pattern-wood" width="100" height="100" patternUnits="userSpaceOnUse">
                    <rect width="100" height="100" fill="#a67c52" />
                    <path d="M0 20 Q 50 10 100 20 M0 50 Q 50 60 100 50 M0 80 Q 50 70 100 80" stroke="#8d6641" fill="none" stroke-width="2" />
                </pattern>

                <pattern id="pattern-flowers" width="60" height="60" patternUnits="userSpaceOnUse">
                    <rect width="60" height="60" fill="#faf3e0" />
                    <text x="10" y="30" font-size="20" opacity="0.4">âœ¿</text>
                    <text x="40" y="50" font-size="15" opacity="0.3">â€</text>
                </pattern>

                <pattern id="pattern-linen" width="10" height="10" patternUnits="userSpaceOnUse">
                    <rect width="10" height="10" fill="#f5f5f5" />
                    <path d="M 10 0 L 10 10 M 0 10 L 10 10" stroke="#e0e0e0" stroke-width="0.5" />
                </pattern>

                <pattern id="pattern-custom" width="100%" height="100%" patternUnits="objectBoundingBox">
                    <image id="custom-mask-img" width="100%" height="100%" preserveAspectRatio="xMidYMid slice" xlink:href="" />
                </pattern>

                <mask id="hole-mask">
                    <rect width="100%" height="100%" fill="white" />
                    <g id="mask-holes-group"></g>
                </mask>
            </defs>
            <rect id="mask-rect" width="100%" height="100%" fill="url(#grad-warm)" mask="url(#hole-mask)" />
        </svg>

        <div id="interaction-layer"></div>
    </div>

    <!-- å…¨è¢å¹•ä¸‹å·¥å…·åˆ— -->
    <div class="game-toolbar">
        <div class="action-grid">
            <div class="action-row">
                <button class="btn btn-outline" onclick="goToPrevImage()">â®ï¸ ä¸Šä¸€é¡Œ</button>
                <button class="btn btn-outline" onclick="toggleAnswerRevealed()">ğŸ“¢ å…¬ä½ˆç­”æ¡ˆ</button>
                <button class="btn btn-outline" onclick="goToNextImage()">â­ï¸ ä¸‹ä¸€é¡Œ</button>
            </div>
            <div class="action-row">
                <button class="btn btn-outline" onclick="resetHoles()">ğŸ”„ é‡æ–°åˆ†ä½ˆ</button>
                <button class="btn btn-outline" onclick="undoHole()">â†©ï¸ å›ä¸Šä¸€æ­¥</button>
                <button class="btn btn-outline" onclick="revealAll()">ğŸ‘ï¸ å…¨éƒ¨æˆ³é–‹</button>
            </div>
        </div>
    </div>
</div>

<div class="control-panel" id="main-controls">
    <!-- æ¨¡å¼åˆ‡æ›æŒ‰éˆ•ï¼šçµ±ä¸€å°ºå¯¸ä¸¦å‹•æ…‹åˆ‡æ›é¡è‰² -->
    <div class="action-row" style="margin-bottom: 24px;">
        <button class="btn btn-outline" id="btn-fullscreen" onclick="enterMockFullscreen()">ğŸ“º å…¨è¢å¹•æ¨¡å¼</button>
        <button class="btn btn-outline" id="btn-preview" onclick="togglePreview()">ğŸ‘€ èª¿æ•´åœ–ç‰‡æ¨¡å¼</button>
    </div>

    <!-- æ ¸å¿ƒæ“ä½œæŒ‰éˆ•å€ (ä¸»ç•«é¢) -->
    <div class="control-group" style="background: #fff9f0; padding: 20px; border-radius: 20px; border: 1px solid #ffeaa7;">
        <div class="action-grid">
            <div class="action-row">
                <button class="btn btn-outline" onclick="goToPrevImage()">â®ï¸ ä¸Šä¸€é¡Œ</button>
                <button class="btn btn-outline" onclick="toggleAnswerRevealed()">ğŸ“¢ å…¬ä½ˆç­”æ¡ˆ</button>
                <button class="btn btn-outline" onclick="goToNextImage()">â­ï¸ ä¸‹ä¸€é¡Œ</button>
            </div>
            <div class="action-row">
                <button class="btn btn-outline" onclick="resetHoles()">ğŸ”„ é‡æ–°åˆ†ä½ˆ</button>
                <button class="btn btn-outline" onclick="undoHole()">â†©ï¸ å›ä¸Šä¸€æ­¥</button>
                <button class="btn btn-outline" onclick="revealAll()">ğŸ‘ï¸ å…¨éƒ¨æˆ³é–‹</button>
            </div>
        </div>
    </div>

    <!-- è¨­å®šå€å¡Š -->
    <div class="control-group">
        <div class="label-row">
            <span>1. åœ–ç‰‡æ¸…å–®èˆ‡é®ç½©æ¨£å¼</span>
            <div class="pattern-options">
                <div class="pattern-btn active" style="background: #e67e22;" onclick="changeMask('warm', this)"></div>
                <div class="pattern-btn" style="background: #a67c52;" onclick="changeMask('wood', this)"></div>
                <div class="pattern-btn" style="background: #faf3e0; border: 1px solid #ddd;" onclick="changeMask('flowers', this)"></div>
                <div class="pattern-btn" style="background: #f5f5f5; border: 1px solid #ddd;" onclick="changeMask('linen', this)"></div>
                <div class="pattern-btn btn-add-mask" id="btn-custom-mask" title="ä¸Šå‚³è‡ªå®šç¾©é®ç½©" onclick="document.getElementById('mask-upload-input').click()">ï¼‹</div>
            </div>
        </div>
        
        <div style="margin-top: 10px; display: flex; gap: 10px;">
            <button class="btn btn-secondary btn-small" onclick="document.getElementById('file-input').click()">â• ä¸Šå‚³é¡Œç›®åœ–</button>
            <button class="btn btn-outline btn-small" onclick="clearAllData()">ğŸ—‘ï¸ æ¸…ç©ºæ‰€æœ‰</button>
            <input type="file" id="file-input" accept="image/*" multiple style="display:none">
            <input type="file" id="mask-upload-input" accept="image/*" style="display:none" onchange="uploadCustomMask(this)">
        </div>

        <div class="image-list" id="image-list-ui"></div>

        <div id="current-adjust" style="display:none; padding: 15px; background: #fdfdfd; border-radius: 16px; margin-top: 10px; border: 1px solid #eee;">
            <label class="label-row">ğŸ” ç•¶å‰åœ–ç‰‡å¤§å°: <span id="scale-val">100%</span></label>
            <input type="range" id="scale-slider" min="10" max="300" value="100">
        </div>
    </div>

    <div class="control-group">
        <div class="label-row">2. æ´å£åƒæ•¸è¨­å®š</div>
        <div style="display: flex; flex-wrap: wrap; gap: 15px; align-items: center;">
            <div>æ•¸é‡: <select id="hole-count" onchange="resetHoles()"><option value="4">4</option><option value="6">6</option><option value="8" selected>8</option><option value="12">12</option><option value="16">16</option><option value="24">24</option></select></div>
            <div>å½¢ç‹€: <select id="hole-shape" onchange="resetHoles()"><option value="circle">åœ“å½¢</option><option value="square">æ–¹å½¢</option></select></div>
            <div>æ’åˆ—: <select id="hole-layout" onchange="resetHoles()"><option value="random">éš¨æ©Ÿåˆ†æ•£</option><option value="grid">æ•´é½Šç¶²æ ¼</option></select></div>
        </div>
        <div style="margin-top: 15px;">
            <label class="label-row">ğŸ•³ï¸ æ´å£å¤§å°: <span id="size-val">120px</span></label>
            <input type="range" id="size-slider" min="50" max="250" value="120" oninput="updateSizeUI()">
        </div>
    </div>
</div>

<footer>
    è¨­è¨ˆï¼š<a href="https://www.facebook.com/kevin.pptgame" target="_blank">è·èƒ½æ²»ç™‚å¸« - é„­å‡±æ–‡</a>
</footer>

<script>
    // --- IndexedDB ---
    const DB_NAME = 'GuessGameDB_V2';
    const STORE_NAME = 'imagesStore';
    const DB_VERSION = 1;
    let db;

    function initDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains(STORE_NAME)) db.createObjectStore(STORE_NAME);
            };
            request.onsuccess = (e) => { db = e.target.result; resolve(db); };
            request.onerror = (e) => reject(e.target.error);
        });
    }

    async function saveToDB(data) {
        if (!db) await initDB();
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        return new Promise((resolve, reject) => {
            const request = store.put(data, 'gameState');
            request.onsuccess = () => resolve();
            request.onerror = (e) => reject(e.target.error);
        });
    }

    async function loadFromDB() {
        if (!db) await initDB();
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        return new Promise((resolve, reject) => {
            const request = store.get('gameState');
            request.onsuccess = (e) => resolve(e.target.result);
            request.onerror = (e) => reject(e.target.error);
        });
    }

    // --- è®Šæ•¸ç®¡ç† ---
    let images = []; 
    let currentIndex = -1;
    let isPreview = false;
    let isAnswerRevealed = false;
    let isDraggingImg = false;
    let startX, startY;
    let holeData = []; 

    const canvas = document.getElementById('game-canvas');
    const imgLayer = document.getElementById('image-layer');
    const interactionLayer = document.getElementById('interaction-layer');
    const maskHolesGroup = document.getElementById('mask-holes-group');
    const maskRect = document.getElementById('mask-rect');
    const listUI = document.getElementById('image-list-ui');
    const scaleSlider = document.getElementById('scale-slider');
    const sizeSlider = document.getElementById('size-slider');
    const fsTarget = document.getElementById('fullscreen-target');
    const btnFullscreen = document.getElementById('btn-fullscreen');
    const btnPreview = document.getElementById('btn-preview');

    window.onload = async () => {
        try {
            const savedData = await loadFromDB();
            if (savedData && Array.isArray(savedData)) {
                images = savedData;
                if (images.length > 0) {
                    currentIndex = 0;
                    renderList();
                    loadCurrent();
                }
            }
        } catch (e) { console.error("DB Load Fail", e); }
        resetHoles();
        setupInteraction();
    };

    // --- æ¨¡å¼åˆ‡æ›èˆ‡å…¨è¢å¹• ---
    function togglePreview() {
        isPreview = !isPreview;
        if (isPreview) {
            fsTarget.classList.add('preview-active');
            btnPreview.classList.add('btn-active');
            btnPreview.innerText = 'ğŸ® è¿”å›éŠæˆ²';
        } else {
            fsTarget.classList.remove('preview-active');
            btnPreview.classList.remove('btn-active');
            btnPreview.innerText = 'ğŸ‘€ èª¿æ•´åœ–ç‰‡æ¨¡å¼';
        }
    }

    function enterMockFullscreen() {
        fsTarget.classList.add('mock-fullscreen');
        btnFullscreen.classList.add('btn-active');
        document.getElementById('page-header').style.display = 'none';
        setTimeout(resetHoles, 300);
    }

    function exitMockFullscreen() {
        fsTarget.classList.remove('mock-fullscreen');
        btnFullscreen.classList.remove('btn-active');
        document.getElementById('page-header').style.display = 'block';
        setTimeout(resetHoles, 300);
    }

    // --- æ ¸å¿ƒå°è¦½åŠŸèƒ½ ---
    function toggleAnswerRevealed() {
        if (isPreview) return; 
        isAnswerRevealed = !isAnswerRevealed;
        if (isAnswerRevealed) {
            fsTarget.classList.add('hide-mask');
        } else {
            fsTarget.classList.remove('hide-mask');
        }
    }

    function goToNextImage() {
        if (images.length === 0) return;
        prepareSwitch();
        currentIndex = (currentIndex + 1) % images.length;
        completeSwitch();
    }

    function goToPrevImage() {
        if (images.length === 0) return;
        prepareSwitch();
        currentIndex = (currentIndex - 1 + images.length) % images.length;
        completeSwitch();
    }

    function prepareSwitch() {
        imgLayer.style.opacity = '0';
        imgLayer.style.display = 'none';
        imgLayer.src = ''; 
        isAnswerRevealed = false;
        fsTarget.classList.remove('hide-mask');
    }

    function completeSwitch() {
        resetHoles(); 
        renderList();
        loadCurrent();
    }

    function loadCurrent() {
        if (currentIndex === -1 || !images[currentIndex]) { imgLayer.style.display = 'none'; return; }
        const img = images[currentIndex];
        imgLayer.style.display = 'none';
        imgLayer.style.opacity = '0';
        imgLayer.src = img.src;
        imgLayer.onload = () => {
            imgLayer.style.display = 'block';
            setTimeout(() => { imgLayer.style.opacity = '1'; }, 100);
        };
        scaleSlider.value = img.scale * 100;
        document.getElementById('scale-val').innerText = Math.round(img.scale * 100) + '%';
        refreshMask();
        updateTransform();
    }

    // --- æ¨£å¼è¨­å®šèˆ‡è‡ªå®šç¾©é®ç½© ---
    function changeMask(type, btn) {
        let fill = '';
        const isDarkTextNeeded = (type === 'flowers' || type === 'linen' || type === 'custom');
        
        if (type === 'warm') fill = 'url(#grad-warm)';
        else if (type === 'wood') fill = 'url(#pattern-wood)';
        else if (type === 'flowers') fill = 'url(#pattern-flowers)';
        else if (type === 'linen') fill = 'url(#pattern-linen)';
        else if (type === 'custom') fill = 'url(#pattern-custom)';

        maskRect.setAttribute('fill', fill);
        document.querySelectorAll('.pattern-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');

        if (isDarkTextNeeded) interactionLayer.classList.add('dark-text'); 
        else interactionLayer.classList.remove('dark-text'); 
    }

    function uploadCustomMask(input) {
        const file = input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            const customImg = document.getElementById('custom-mask-img');
            customImg.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', e.target.result);
            const btn = document.getElementById('btn-custom-mask');
            btn.style.backgroundImage = `url(${e.target.result})`;
            btn.innerText = '';
            changeMask('custom', btn);
        };
        reader.readAsDataURL(file);
    }

    document.getElementById('file-input').addEventListener('change', function(e) {
        const files = Array.from(e.target.files);
        let loaded = 0;
        files.forEach(file => {
            const reader = new FileReader();
            reader.onload = async (ev) => {
                images.push({
                    id: 'i_' + Date.now() + Math.random(),
                    src: ev.target.result,
                    name: file.name,
                    scale: 1, posX: 0, posY: 0,
                    revealedIds: []
                });
                loaded++;
                if (loaded === files.length) {
                    if (currentIndex === -1) currentIndex = 0;
                    renderList(); loadCurrent(); await save();
                }
            };
            reader.readAsDataURL(file);
        });
    });

    function renderList() {
        listUI.innerHTML = '';
        if (images.length === 0) { document.getElementById('current-adjust').style.display = 'none'; return; }
        document.getElementById('current-adjust').style.display = 'block';
        images.forEach((img, idx) => {
            const item = document.createElement('div');
            item.className = `image-item ${idx === currentIndex ? 'active' : ''}`;
            item.draggable = true;
            item.innerHTML = `<div class="item-num">${idx + 1}</div><img src="${img.src}" class="thumb"><div style="flex:1; font-weight:600; font-size:15px; color:var(--text-main);">${img.name.substring(0,15)}...</div><button class="btn btn-outline btn-small" style="padding:0 10px; min-height:36px;" onclick="deleteImg(event, ${idx})">âœ•</button>`;
            item.ondragstart = (e) => { e.dataTransfer.setData('text/plain', idx); item.classList.add('dragging'); };
            item.ondragend = () => item.classList.remove('dragging');
            item.ondragover = (e) => e.preventDefault();
            item.ondrop = async (e) => {
                e.preventDefault();
                const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
                const toIdx = idx;
                if (fromIdx !== toIdx) {
                    const movedItem = images.splice(fromIdx, 1)[0];
                    images.splice(toIdx, 0, movedItem);
                    currentIndex = toIdx; 
                    renderList(); loadCurrent(); await save();
                }
            };
            item.onclick = () => { currentIndex = idx; isAnswerRevealed = false; fsTarget.classList.remove('hide-mask'); renderList(); loadCurrent(); };
            listUI.appendChild(item);
        });
    }

    async function deleteImg(e, idx) { e.stopPropagation(); images.splice(idx, 1); if (currentIndex >= images.length) currentIndex = images.length - 1; renderList(); loadCurrent(); await save(); }

    function updateTransform() {
        if (currentIndex === -1) return;
        imgLayer.style.transform = `translate(${images[currentIndex].posX}px, ${images[currentIndex].posY}px) scale(${images[currentIndex].scale})`;
    }

    scaleSlider.oninput = async (e) => {
        if (currentIndex === -1) return;
        images[currentIndex].scale = e.target.value / 100;
        document.getElementById('scale-val').innerText = e.target.value + '%';
        updateTransform();
        await save();
    };

    function updateSizeUI() { document.getElementById('size-val').innerText = sizeSlider.value + 'px'; }

    function resetHoles() {
        interactionLayer.innerHTML = '';
        maskHolesGroup.innerHTML = '';
        holeData = [];
        const count = parseInt(document.getElementById('hole-count').value);
        const size = parseInt(sizeSlider.value);
        const shape = document.getElementById('hole-shape').value;
        const layout = document.getElementById('hole-layout').value;
        const rect = canvas.getBoundingClientRect();
        const cw = rect.width || 800;
        const ch = rect.height || 600;

        if (layout === 'grid') {
            const cols = Math.ceil(Math.sqrt(count));
            const rows = Math.ceil(count / cols);
            const cellW = cw / cols;
            const cellH = ch / rows;
            for (let i = 0; i < count; i++) {
                const r = Math.floor(i / cols);
                const c = i % cols;
                addHole(i + 1, c * cellW + (cellW - size) / 2, r * cellH + (cellH - size) / 2, size, shape);
            }
        } else {
            for (let i = 0; i < count; i++) {
                let attempts = 0;
                while (attempts < 200) {
                    const x = Math.random() * (cw - size);
                    const y = Math.random() * (ch - size);
                    const overlap = holeData.some(h => Math.sqrt(Math.pow(x - h.x, 2) + Math.pow(y - h.y, 2)) < size);
                    if (!overlap) { addHole(i + 1, x, y, size, shape); break; }
                    attempts++;
                }
            }
        }
        if (currentIndex !== -1) { images[currentIndex].revealedIds = []; save(); }
    }

    function addHole(num, x, y, size, shape) {
        const id = `h-${num}`;
        holeData.push({id, x, y, size, shape});
        const trigger = document.createElement('div');
        trigger.className = 'hole-trigger';
        trigger.id = `trigger-${id}`;
        trigger.innerText = num;
        trigger.style.width = trigger.style.height = size + 'px';
        trigger.style.left = x + 'px';
        trigger.style.top = y + 'px';
        trigger.style.borderRadius = shape === 'circle' ? '50%' : '16px';
        trigger.onclick = () => poke(id);
        interactionLayer.appendChild(trigger);
    }

    async function poke(id) {
        if (isPreview || currentIndex === -1 || isAnswerRevealed) return;
        if (!images[currentIndex].revealedIds.includes(id)) {
            images[currentIndex].revealedIds.push(id);
            refreshMask(); await save();
        }
    }

    function refreshMask() {
        maskHolesGroup.innerHTML = '';
        const revealed = (currentIndex !== -1) ? images[currentIndex].revealedIds : [];
        holeData.forEach(h => {
            const trigger = document.getElementById(`trigger-${h.id}`);
            if (revealed.includes(h.id)) {
                let shapeEl = document.createElementNS("http://www.w3.org/2000/svg", h.shape === 'circle' ? "circle" : "rect");
                if (h.shape === 'circle') {
                    shapeEl.setAttribute("cx", h.x + h.size / 2); shapeEl.setAttribute("cy", h.y + h.size / 2); shapeEl.setAttribute("r", h.size / 2);
                } else {
                    shapeEl.setAttribute("x", h.x); shapeEl.setAttribute("y", h.y); shapeEl.setAttribute("width", h.size); shapeEl.setAttribute("height", h.size); shapeEl.setAttribute("rx", 16);
                }
                shapeEl.setAttribute("fill", "black"); maskHolesGroup.appendChild(shapeEl);
                if (trigger) trigger.classList.add('revealed');
            } else { if (trigger) trigger.classList.remove('revealed'); }
        });
    }

    async function undoHole() { if (currentIndex === -1) return; images[currentIndex].revealedIds.pop(); refreshMask(); await save(); }
    async function revealAll() { if (currentIndex === -1) return; images[currentIndex].revealedIds = holeData.map(h => h.id); refreshMask(); await save(); }

    function setupInteraction() {
        const start = (e) => { if (currentIndex === -1) return; isDraggingImg = true; const cx = e.touches ? e.touches[0].clientX : e.clientX; const cy = e.touches ? e.touches[0].clientY : e.clientY; startX = cx - images[currentIndex].posX; startY = cy - images[currentIndex].posY; };
        const move = (e) => { if (!isDraggingImg) return; const cx = e.touches ? e.touches[0].clientX : e.clientX; const cy = e.touches ? e.touches[0].clientY : e.clientY; images[currentIndex].posX = cx - startX; images[currentIndex].posY = cy - startY; updateTransform(); };
        const end = async () => { if(isDraggingImg) { isDraggingImg = false; await save(); } };
        canvas.addEventListener('mousedown', start); window.addEventListener('mousemove', move); window.addEventListener('mouseup', end);
        canvas.addEventListener('touchstart', start, {passive: false}); window.addEventListener('touchmove', move, {passive: false}); window.addEventListener('touchend', end);
    }

    async function save() { try { await saveToDB(images); } catch (e) { console.error("Save Error", e); } }
    async function clearAllData() { if (confirm('ç¢ºå®šæ¸…ç©ºæ‰€æœ‰è¨­å®šï¼Ÿ')) { const transaction = db.transaction([STORE_NAME], 'readwrite'); transaction.objectStore(STORE_NAME).clear(); location.reload(); } }
</script>

</body>
</html>
